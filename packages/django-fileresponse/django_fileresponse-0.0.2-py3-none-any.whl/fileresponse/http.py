# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_http.ipynb (unless otherwise specified).

__all__ = ['AsyncResponse', 'AiofileFileResponse', 'AiobotocoreFileResponse']

# Cell

import time

from django.http.response import HttpResponseBase


class AsyncResponse(HttpResponseBase):
    streaming = True  # common middleware needs this
    is_async_fileresponse = True

    def __init__(self, *args, **kwargs):
        self.chunk_size = kwargs.get("chunk_size", 4096)
        self.raw_headers = kwargs.get("raw_headers", {})

        # copy relevant super kwargs from kwargs
        super_kwargs_names = {"content_type", "status", "reason", "charset", "headers"}
        super_kwargs = {key: kwargs.get(key) for key in super_kwargs_names}

        # set default values
        content_type = kwargs.get("content_type", "application/octet-stream")
        super_kwargs["content_type"] = content_type
        status = kwargs.get("status", 200)
        super().__init__(**super_kwargs)

    @property
    def response_headers(self):
        # copied from django.core.handlers.asgi.ASGIHandler.send_response
        response_headers = []
        for header, value in self.items():
            if isinstance(header, str):
                header = header.encode("ascii")
            if isinstance(value, str):
                value = value.encode("latin1")
            response_headers.append((bytes(header), bytes(value)))
        for c in self.cookies.values():
            response_headers.append(
                (b"Set-Cookie", c.output(header="").encode("ascii").strip())
            )
        return response_headers

    async def send_stream_to_client(self, stream, send):
        started_serving = time.perf_counter()
        await send(
            {
                "type": "http.response.start",
                "status": self.status_code,
                "headers": self.response_headers,
            }
        )
        chunks = []
        sent_size = 0

        more_body = True
        while more_body:
            chunk = await stream.read(self.chunk_size)
            chunk_len = len(chunk)
            more_body = chunk_len > 0
            chunks.append(chunk)
            await send(
                {
                    "type": "http.response.body",
                    "body": chunk,
                    "more_body": more_body,
                }
            )
            sent_size += chunk_len
        print("sent size: ", sent_size)
        self.elapsed = time.perf_counter() - started_serving

# Cell

import aiofiles


class AiofileFileResponse(AsyncResponse):
    def __init__(self, path, chunk_size=4096):
        super().__init__(path, chunk_size=chunk_size)
        self.path = path

    def __repr__(self):
        return "<%(cls)s status_code=%(status_code)d>" % {
            "cls": self.__class__.__name__,
            "status_code": self.status_code,
        }

    async def stream(self, send):
        async with aiofiles.open(self.path, mode="rb") as stream:  # type: ignore
            await self.send_stream_to_client(stream, send)

# Cell

import aiobotocore

from django.conf import settings


class AiobotocoreFileResponse(AsyncResponse):
    def __init__(self, bucket, key, chunk_size=4096):
        super().__init__(chunk_size=chunk_size)
        self.bucket = bucket
        self.key = key

    def __repr__(self):
        return "<%(cls)s status_code=%(status_code)d>" % {
            "cls": self.__class__.__name__,
            "status_code": self.status_code,
        }

    async def stream(self, send):
        session = aiobotocore.get_session()
        async with session.create_client(
            "s3",
            endpoint_url=settings.MINIO_ENDPOINT_URL,
            region_name=settings.DJANGO_AWS_REGION,
            aws_secret_access_key=settings.DJANGO_AWS_SECRET_ACCESS_KEY,
            aws_access_key_id=settings.DJANGO_AWS_ACCESS_KEY_ID,
            use_ssl=False,
        ) as client:
            minio_response = await client.get_object(Bucket=self.bucket, Key=self.key)
            async with minio_response["Body"] as stream:
                await self.send_stream_to_client(stream, send)