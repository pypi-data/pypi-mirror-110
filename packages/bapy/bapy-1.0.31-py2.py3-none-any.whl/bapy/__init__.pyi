import abc
import ast
import asyncio.events
import collections
import contextlib
import dataclasses
import enum
import functools
import importlib
import inspect
import io
import ipaddress
import os
import pathlib
import pwd
import re
import subprocess
import sys
import threading
import typing
from collections.abc import ByteString as ByteString
from collections.abc import Callable as Callable
from collections.abc import Container as Container
from collections.abc import Generator as Generator
from collections.abc import Iterable as Iterable
from collections.abc import Iterator as Iterator
from collections.abc import KeysView as KeysView
from collections.abc import Mapping as Mapping
from collections.abc import MutableMapping as MutableMapping
from collections.abc import MutableSequence as MutableSequence
from collections.abc import MutableSet as MutableSet
from collections.abc import Sequence as Sequence
from collections.abc import Sized as Sized
from collections.abc import ValuesView as ValuesView
from pkgutil import MetaPathFinder
from shelve import DbfilenameShelf
from types import BuiltinFunctionType
from types import BuiltinMethodType
from types import CodeType
from types import FrameType
from types import FunctionType
from types import GenericAlias
from types import LambdaType
from types import MethodType
from types import ModuleType
from types import SimpleNamespace
from types import TracebackType
from typing import Any
from typing import AnyStr
from typing import Final
from typing import Generic
from typing import Literal
from typing import NamedTuple
from typing import Optional
from typing import overload
from typing import Type
from typing import TypedDict
from typing import TypeVar
from typing import Union

import box
import decorator
import devtools
import distro
import environs
import furl
import git
import inflect
import intervaltree
import jinja2
import rich.console
import semver
import setuptools.command.install
import typer

__all__: tuple[str, ...]
__version__: str
# Defaults
CMS_INSTALL_POST_DEFAULT: Union[_T, bool] = ...
FILE_DEFAULT: Union[_T, bool] = ...
FRAME_INDEX: Union[_T, int] = ...
GIT_VERSIONS: Union[_T, int] = ...
STDOUT_DEFAULT: Union[_T, bool] = ...
SUDO_DEFAULT: Union[_T, bool] = ...

# Vars
Alias = typing._alias
ALL_PORTS: range = ...
APP_CONTEXT: dict[str, Any] = ...
app: typer.Typer = ...
AsyncsUnion = Union[ast.AsyncFor, ast.AsyncWith, ast.Await]
BASE_EXEC_PREFIX: str = ...
BASE_EXECUTABLE: str = ...
BASE_PREFIX: str = ...
# noinspection PyAnnotations
BaseTypesUnion = Union[int, float, list, dict, set, tuple, object, bytes]
BASE_TYPES: set[Type, ...] = ...
Bool = bool
BUILTIN: DictStrAny = ...
BUILTIN_CLASS: TupleType = ...
BUILTIN_CLASS_NO_EXCEPTION: TupleType = ...
BUILTIN_CLASS_DICT: TupleType = ...
BUILTIN_CLASS_NO_DICT: TupleType = ...
BUILTIN_FUNCTION: TupleType = ...
BUILTIN_MODULE_NAMES: Sequence[str] = ...
cancel_all_tasks = asyncio.runners._cancel_all_tasks
console: rich.console.Console
cp: Any = ...
CRLock = threading._CRLock
CURLYBRACKETS: str = ...
current_frames = sys._current_frames
datafield: Final[dataclasses.field]
DATA_MISSING = dataclasses.MISSING
debug: devtools.Debug
DEFAULT_FACTORY = dataclasses._HAS_DEFAULT_FACTORY_CLASS
DefsUnion = Union[ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Lambda]
Dict = dict
DictStrAny = dict[str, Any]
DISTRO: distro.LinuxDistribution()
EXEC_PREFIX: str = ...
ExceptionUnion = Union[tuple[Type[Exception]], Type[Exception]]
EXECUTABLE: pathlib.Path = ...
EXECUTABLE_SITE: pathlib.Path = ...
FIELD: Final[dataclasses._FIELD]
FIELD_BASE = dataclasses._FIELD_BASE
FIELD_CLASSVAR: Final[dataclasses._FIELD_CLASSVAR]
FIELD_INITVAR: Final[dataclasses._FIELD_INITVAR]
FlagsType = typing.Union[int, re.RegexFlag]
fmic: Any = ...
fmicc: Any = ...
FQDN: str = ...
FRAME: FrameType = ...
Frames = Union[inspect.FrameInfo, FrameType, TracebackType]
FUNCTION_MODULE: str = ...
FunctionTypesUnion = Union[FunctionType, MethodType, LambdaType, BuiltinFunctionType,
                                  BuiltinMethodType]
FUNCTION_TYPES: set[Type, ...]
getframe = sys._getframe
GitCommandWrapperType = git.Repo.GitCommandWrapperType
HOSTNAME: str = ...
HTTP_EXCEPTIONS: TupleType = ...
ic: Any = ...
icc: Any = ...
ID_RSA_PUB: str = ...
INIT_PY: str = ...
inspect_empty = inspect._empty
IPv = typing.Union[ipaddress.IPv4Address, ipaddress.IPv6Address]
IMPORTLIB_BOOTSTRAP: str = ...
IMPORTLIB_BOOTSTRAP_EXTERNAL: str = ...
IMPORTLIB_PYCACHE: str = ...
IteratorTypes = (type(iter('')),)
KALI: bool = ...
LINUX: bool = ...
List = list
USERLOCAL: pathlib.Path = ...
LOCALBIN: pathlib.Path = ...
LOCALHOST: str = ...
LST = Union[list, set, tuple]
LST_TYPES: tuple[Type, ...] = ...
MACOS: bool = ...
MACHINE: str = ...
MANIFEST: str = ...
MatchAnyStr = typing.Match[AnyStr]
MatchCallable = typing.Callable[[MatchAnyStr], AnyStr]
MatchCallableUnion = typing.Union[typing.Callable[[MatchAnyStr], AnyStr], AnyStr]
MatchIterator = typing.Iterator[MatchAnyStr]
MatchOptional = typing.Optional[MatchAnyStr]
META_PATH: list[MetaPathFinder] = ...
ModuleSpec = importlib._bootstrap.ModuleSpec
MONGO_CONF: str = ...
MONGO_EXCEPTIONS: TupleType = ...
NEWLINE: str
NODE: str = ...
OpenIO = Union[io.BufferedRandom, io.BufferedReader, io.BufferedWriter, io.FileIO, io.TextIOWrapper]
PATH_HOOKS: list[Type, FunctionType] = ...
PATHLIBDIR: str = ...
PLATFORM: str = ...
PatternUnion = typing.Union[typing.AnyStr, typing.Pattern[typing.AnyStr]]
plural = inflect.engine().plural
PrimitiveTypesUnion = Union[str, bool, type(None), int, float]
PRIMITIVE_TYPES: set[Type, ...] = ...
NON_REDUCTIBLE_TYPES: set[Type, ...] = ...
print_exception: Any = ...
PROCESSOR: str = ...
PYTHON_IMPLEMENTATION: str = ...
PYTHON_VERSION: str = ...
PYTHON_VERSIONS: tuple[semver.VersionInfo, semver.VersionInfo]
PYTHON_VERSION_TUPLE: typing.Tuple[str, str, str] = ...
RELEASE: str = ...
RunningLoop = asyncio.events._RunningLoop
SeqTuple = Union[typing.MutableSequence, typing.MutableSet, tuple]
SYSCONFIG_PATHS: dict[str, pathlib.Path] = ...
SCRIPTS: pathlib.Path = ...
Simple = SimpleNamespace
SOCKET_VERSION: dict[int, dict[str, int]] = ...
SPECIAL_CHARACTERS: str = ...
SSH_CONFIG: DictStrAny = ...
SSH_CONFIG_TEXT: str = ...
Str = str
SUDO_USER: str = ...
SUDO: bool = ...
SYSPATH: list[str, ...] = ...
SYSPREFIX: str = ...
TEMPDIR: pathlib.Path = ...
ThreadLock = threading.Lock
LockClass = type(ThreadLock())
Tuple = tuple
TupleStr = tuple[str, ...]
TupleType = tuple[Type, ...]
UBUNTU: str = ...
SeqNoStr = Union[typing.Iterator, typing.KeysView, typing.MutableSequence, typing.MutableSet, typing.Sequence,
                        tuple, typing.ValuesView]
SeqUnion = Union[bytes, typing.ByteString, SeqNoStr, str]
VENV: bool = ...
WITHSUDO: str = ...
# TypeVars
_Annotation = TypeVar('_Annotation', bound='Annotation')
_Is = TypeVar('_Is', bound='Is')
_Path = TypeVar('_Path', bound='Path')
_T = TypeVar('_T')
_KT = TypeVar('_KT')
_U = TypeVar('_U')
_VT = TypeVar('_VT')
_T_co = TypeVar('_T_co', covariant=True)  # Any type covariant containers.
# Functions
def aioclosed() -> bool: ...
async def aiocmd(command: Union[str, list], decode: bool = ..., utf8: bool = ...,
                 lines: bool = ...) -> subprocess.CompletedProcess: ...
def aioloop() -> Optional[RunningLoop]: ...
def aioloopid() -> Optional[int]: ...
def aiorunning() -> bool: ...
def allin(origin: Iterable, destination: Iterable) -> bool: ...
def annotations(data: Any, index: int = ...) -> DictStrAny: ...
def annotations_init(data: Any = ..., optional: bool = ..., **kwargs: Any) -> Any: ...
def anyin(origin: Iterable, destination: Iterable) -> Optional[Any]: ...
class _cache_wrapper(Generic[_T]):
    __wrapped__: Callable[..., _T]
    def __call__(self, *args: Any, **kwargs: Any) -> _T: ...
def cache(__func: Callable[..., _T] = ...) -> Union[Callable[[Callable[..., _T]], _cache_wrapper[_T]], _T]: ...
def cmd(command: Iterable, exc: bool = ..., lines: bool = ..., shell: bool = ..., py: bool = ...,
        pysite: bool = ...) -> Union[subprocess.CompletedProcess, int, list, str]: ...
def cmdname(func: Callable, sep: str = ...) -> str: ...
def current_task_name() -> str: ...
@functools.singledispatch
def delete(data: Union[MutableMapping, list], key: Iterable = ...) -> Optional[dict]: ...
@delete.register
def delete_list(data: list, key: Iterable = ...) -> Optional[list]: ...
def dict_sort(data: dict[_KT, _VT], ordered: bool = ...,
              reverse: bool = ...) -> Union[dict[_KT, _VT], collections.OrderedDict[_KT, _VT]]:...
def effect(apply: typing.Callable, data: typing.Iterable) -> Optional[typing.Iterator]: ...
def enumvalue(data: Any) -> Any:...
def filterm(d: dict[_KT, _VT], k: typing.Callable[..., bool] = ...,
            v: typing.Callable[..., bool] = ...) -> typing.MutableMapping[_KT, _VT]: ...
def firstfound(data: typing.Iterable, apply: typing.Callable) -> Any: ...
def flatten(data: LST, recurse: bool = ..., unique: bool = ..., sort: bool = ...) -> LST: ...
def framesimple(data: Any) -> FrameSimple:...
def fromiter(data: typing.Sequence[Any, ...], *args: Union[str, nstr, typing.Iterable[str, nstr]]) -> DictStrAny: ...
def funcdispatch(func: Callable):...
def get(data: Any, *args: Any, default: Any = ..., one: bool = ..., recursive: bool = ...,
        with_keys: bool = ...) -> Any:...
def getcls(data: Any) -> Type[Any]:...
def getf(data: Any, name: str, default: Any = ...) -> Any:...
def getm(data: Union[typing.MutableMapping, Any], name: Any = ...) -> Optional[Any, MISSING]: ...
@overload
def getnostr(data: str, attr: Optional[str] = ...) -> str:...
@overload
def getnostr(data: Any, attr: Optional[str] = ...) -> str:...
def getprops(data: Any) -> DictStrAny: ...
def getset(data: Any, name: str, default: Any = ..., setvalue: bool = ...) -> Any:...
@overload
def getsetstate(data: Any) -> DictStrAny: ...
@overload
def getsetstate(data: Any, state: DictStrAny = ...) -> Any: ...
def has(data: Any, name: Union[str, nstr]) -> bool: ...
def hasget(data: Any, name: Union[str, nstr], default: Any = ...) -> Any: ...
def hasgetany(obj: Any, name: Union[str, nstr], default: Any = ...) -> Any: ...
def importname(data: Any) -> str: ...
def indict(data: typing.MutableMapping, items: typing.MutableMapping = ..., **kwargs: Any) -> bool: ...
def indictr(data: typing.MutableMapping, items: typing.MutableMapping = ..., **kwargs: Any) -> bool: ...
def initimps(path: PathLikeStr = ..., relative: bool = ...) -> tuple[tuple[ModuleType, ...], str, str]: ...
def iscoro(data: Any) -> bool: ...
def iseven(number: int) -> bool: ...
def istype(data: Any) -> bool: ...
def join_newline(data: typing.Iterable[str]) -> str: ...
def localbin(path: Any = __file__) -> None: ...
def map_reduce_even(iterable: typing.Iterable[_T]) -> list[_U, list[_T]]:...
def map_with_args(data: Any, func: typing.Callable, /, *args, pred: typing.Callable = lambda x: True if x else False,
                  split: str = ' ', **kwargs) -> list: ...
def missing(data: Any) -> bool: ...
def newprop(name: str = ..., default: Optional[Any, typing.Callable, functools.partial] = ...) -> property: ...
def noexc(func: typing.Callable[..., _T], *args, default_: Any = ..., exc_: ExceptionUnion = ...,
          **kwargs: Any) -> _T: ...
def notmissing(data: Any) -> bool: ...
def notstart(name: str, start: str = ...): ...
@overload
def objname(data: Any) -> str: ...
@overload
def objname(data: Type[None] = ..., stack: Union[int, inspect.FrameInfo] = ...) -> str: ...
def prefixed(name: str) -> str: ...
def pretty_install(cons: rich.console.Console = ..., expand: bool = ...): ...
def pypifree(name: str, stdout: bool = False) -> bool: ...
def reprcls(data: Any = ..., attrs: typing.Iterable = ..., line: bool = ..., module: bool = ...,
            sort: bool = ..., **kwargs: Any) -> str: ...
def reprkw(data: Any = ..., attrs: typing.Iterable = ..., line: bool = ...,
           sort: bool = ..., start: str = ..., **kwargs: Any) -> str: ...
def sourcepath(data: Any) -> Path: ...
def sourcevars() -> dict[str, str]: ...
@decorator.decorator
def runwarning(func: typing.Callable, *args: Any, **kwargs: Any) -> Any: ...
def splitsep(sep: str = ...): ...
def to_camel(text: str, replace: bool = True) -> str: ...
def toiter(data: Any, split: str = ...) -> Union[typing.Sized, typing.MutableMapping, typing.Sequence,
                                                               typing.MutableSequence]: ...
def tomodules(data: Any, suffix: bool = ...) -> str: ...
def traceback_install(cons: rich.console.Console = ..., extra: int = ..., locs: bool = ...): ...
def varname(index: int = ..., lower: bool = ..., prefix: Optional[str] = ..., sep: str = ...) -> Optional[str]: ...
def _version() -> None: ...
def yield_if(data: Any, pred: typing.Callable = ..., split: str = ...,
             apply: Union[typing.Callable, tuple[Callable, ...]] = ...) -> typing.Generator: ...
def yield_last(data: Any) -> typing.Iterator[tuple[bool, Any, Optional[Any, None]]]: ...
# EnumBase
@functools.total_ordering
class EnumBase(enum.Enum, Generic[_T], _T):
    def __call__(self) -> Any: ...
    def __eq__(self, other: Union[str, Access]) -> bool: ...
    def __gt__(self, other: Union[str, Access]) -> bool: ...
    def __hash__(self) -> int: ...
    def __int__(self) -> int: ...
    def _generate_next_value_(self: str, start: Any, count: Any, last_values: Any) -> str: ...
    @classmethod
    def asdict(cls) -> DictStrAny: ...
    @classmethod
    def attrs(cls) -> list: ...
    @classmethod
    def default(cls) -> Any: ...
    @classmethod
    def default_attr(cls) -> str: ...
    @classmethod
    def default_dict(cls) -> DictStrAny: ...
    @classmethod
    def default_value(cls) -> Any: ...
    describe: tuple = ...
    lower: str = ...
    @classmethod
    def values(cls) -> list: ...
EnumBaseAlias: Alias
class EnumBaseMeta(enum.EnumMeta):
    _member_map_: dict[str, Union[EnumBase, EnumBaseMeta]]
    def __getitem__(cls, item: Any) -> Optional[Access]: ...
    def __class_getitem__(mcs, item: Any) -> Optional[Access]: ...
# Classes
class Access(EnumBase, metaclass=EnumBaseMeta):
    ALL = ...
    PRIVATE = ...
    PROTECTED = ...
    PUBLIC = ...
    @classmethod
    def classify(cls, *args: str, **kwargs: Union[enum.Enum, Any]) -> AccessEnumMembers: ...
    def es(self, name: str) -> bool: ...
    def include(self, name: str) -> Optional[bool]: ...
_AccessEnumMember = Union[dict[str,typing. Union[enum.Enum, Any]], list[str]]
AccessEnumMembers = NamedTuple('AccessEnumMembers', all=_AccessEnumMember, private=_AccessEnumMember,
                                       protected=_AccessEnumMember, public=_AccessEnumMember)
class AllAttr(metaclass=abc.ABCMeta):
    __slots__: TupleStr = ...
    __all__: TupleStr = ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
Annotation = NamedTuple('Annotation', any=bool, args=list[Generic[_Annotation], ...],
                               classvar=bool, cls=Type, default=Any, final=bool,
                               hint=Type, initvar=bool, literal=bool, name=str, optional=bool,
                               origin=Any, union=bool)
class AnnotationsAttr(metaclass=abc.ABCMeta):
    __slots__: TupleStr = ...
    __annotations__: DictStrAny = ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class AsDictMethod(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def asdict(self, *args: Any, **kwargs: Any) -> DictStrAny: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class AsDictProperty(metaclass=abc.ABCMeta):
    @property
    @abc.abstractmethod
    def asdict(self) -> DictStrAny: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class Kind(EnumBase, metaclass=EnumBaseMeta):
    CLASSMETHOD = ...
    CLASSVAR = ...
    DATA = ...
    FACTORY = ...
    INITVAR = ...
    METHOD = ...
    PROPERTY = ...
    STATICMETHOD = ...
    UNKNOWN = ...
Attribute = NamedTuple('Attribute', defining=Type, i=_Is[Any], kind=Kind, object=Any, qualname=str)
class BaseState:
    __slots__: TupleStr = ...
    __state__: TupleStr = ...
    def __getstate__(self) -> DictStrAny: ...
    def __setstate__(self, state: DictStrAny) -> BaseState: ...
class BoxKeys(box.Box[str, Any]):
    def __init__(self, keys: Iterable,
                 value: Optional[Union[Type, Literal['lower']]] = ...) -> None: ...
class ChainRV(EnumBase, metaclass=EnumBaseMeta):
    ALL = ...
    FIRST = ...
    UNIQUE = ...
class Chain(collections.ChainMap):
    rv: ChainRV
    default: Any
    maps: list[Union[Iterable, Namedtuple, MutableMapping]]
    def __init__(self, *maps: ..., rv: ChainRV = ..., default: Any = ...) -> None: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __delitem__(self, key: Any) -> None: ...
    def delete(self, key: Any) -> Chain: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def set(self, key: Any, value: Any) -> None: ...
ClassBase = NamedTuple('ClassBase', annotation=dict[str, DictStrAny], attribute=dict[str, Attribute], cls=Type,
                       coro=set[str, ...], data=DictStrAny, i=_Is[Type[Any]], importable=str, init=DictStrAny,
                       module=str, mro=TupleType, mroitems=collections.defaultdict[str, set[str, ]],
                       property=set[str, ...], qualname=str, routine=set[str, ...],
                       signature=dict[Any, MutableMapping[str, Any]], slot=set[str, ...],)
class Class(ClassBase):
    cache: dict[TypesType, Class] = ...
    __slots__ = ()
    def __new__(cls, data: Union[Is, TypesType]) -> Class: ...
    def __iter__(self) -> Iterator[Str]: ...
    def filter(self, name: Literal['attributes', 'coros', 'data', 'defaults', 'hashs', 'inits', 'nodatas', 'pprops',
                                   'reprs', 'slots', 'states'],
               access: Access = ...) -> Optional[Union[dict, tuple]]: ...
    @classmethod
    def from_obj(cls, data: Any) -> Class: ...
    def state(self, obj: Any = None, access: Access = ...) -> TupleType: ...
    @classmethod
    def vars(cls, data: Any, access: Access = ..., both: bool = ..., ignore: Callable = ...,
             state: bool = ..., prop: bool = ...) -> DictStrAny: ...
class CmdError(Exception):
    def __init__(self, rv: subprocess.CompletedProcess) -> None: ...
class CmdAioError(CmdError):
    def __init__(self, rv: subprocess.CompletedProcess) -> None: ...
class DataClass(metaclass=abc.ABCMeta):
    __annotations__: DictStrAny
    __dataclass_fields__: dict[str, dataclasses.Field]
    def __repr__(self) -> str: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class dd(typing.DefaultDict, MutableMapping[_KT, _VT], Generic[_KT, _VT]):
    __factory__: Optional[Callable]
    __slots__: TupleStr = ...
    @overload
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @overload
    def __init__(self, factory: typing.Callable = ..., *args: Any, **kwargs: Any) -> None: ...
    def __repr__(self) -> str: ...
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
class dictsort(dict, typing.MutableMapping[_KT, _VT], typing.Mapping[_KT, _VT], Generic[_KT, _VT]):
    __slots__: TupleStr = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def sort(self) -> dictsort[_KT, _VT]: ...
class Executor(EnumBase, metaclass=EnumBaseMeta):
    PROCESS = ...
    THREAD = ...
    NONE = ...
    async def run(self, func: Any, *args: Any, **kwargs: Any) -> Any: ...
@typing.runtime_checkable
class GetItem(typing.Protocol):
    __slots__: TupleStr = ...
    @overload
    @abc.abstractmethod
    def __getitem__(self, i: int) -> _T_co: ...
    @overload
    @abc.abstractmethod
    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...
@typing.runtime_checkable
class GetMethod(typing.Protocol):
    __slots__: TupleStr = ...
    @abc.abstractmethod
    def get(self, name: str, default: Any = ...) -> Any: ...
class getter(typing.Callable[[Any], Union[Any, typing.Tuple[Any, ...]]]):
    __slots__: TupleStr = ...
    _attrs: tuple
    _call: typing.Callable[[Any], Union[Any, typing.Tuple[Any, ...]]]
    _copy: bool
    _default: Any = ...
    _mm: bool
    @overload
    def __init__(self, name: Union[str, typing.Iterable[str]], default: Any = ...) -> None: ...
    @overload
    def __init__(self, *name: str, default: Any = ...) -> None: ...
    def __call__(self, obj: Any) -> Union[Any, tuple[Any, ...]]: ...
    def __repr__(self) -> str: ...
    def __reduce__(self)-> tuple[Type[getter], TupleStr]: ...
IntervalBase = NamedTuple('IntervalBase', begin=int, end=int, data=Union[ast.AST, AsyncsUnion, DefsUnion])
IntervalType: intervaltree.Interval[IntervalBase]
class Is(Generic[_T, _Is]):
    __slots__: TupleStr = ...
    _cls: TypesType
    _func: Optional[Callable]
    _iter: typing.Iterator[nstr]  #
    _mro: TupleType
    _mroitems: Dict[Union[Str, nstr], list]
    _type: Bool
    _varstype: Optional[Bool]
    data: Union[_T, inspect.FrameInfo, FrameType, typing.MutableMapping, TracebackType,
                       Any] = ...
    stack: int = ...
    def __init__(self, data: Any = ...) -> None: ...
    def __call__(self) -> TypesType: ...
    def __getstate__(self) -> DictStrAny: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __reduce__(self) -> Tuple[Type[Is], Tuple]: ...
    def __repr__(self) -> Str: ...
    def __setstate__(self, state: DictStrAny): ...
    def __str__(self) -> Str: ...
    allattr: Bool
    annotationsattr: Bool
    asdictmethod: Bool
    asdictproperty: Bool
    ast: Bool
    asyncfor: Bool
    asyncfunctiondef: Bool
    asyncgen: Bool
    asyncgenfunction: Bool
    asyncs: Bool
    asyncwith: Bool
    await_ast: Bool
    awaitable: Bool
    bool: Bool
    builtin: Bool
    builtinclass: Bool
    builtinclassnodict: Bool
    builtinfunction: Bool
    builtinfunctiontype: Bool
    bytesio: Bool
    cached: bool
    cached_property: Bool
    callable: Bool
    chain: Bool
    chainmap: Bool
    classdef: Bool
    classvar: Bool
    classvar_or_initvar: Bool
    cls: TypesType
    clsmethod: Bool
    codetype: Bool
    collections: Bool
    container: Bool
    coro: Bool
    coroutine: Bool
    coroutinefunction: Bool
    dataclass: Bool
    datafield: Bool
    datamissing: Bool
    defaultdict: Bool
    defs: Bool
    deleter: Bool
    dict: Bool
    dynamicclassattribute: Bool
    dlst: Bool
    enum: Bool
    enum_sub: Bool
    enumbase: Bool
    enumbase_sub: Bool
    even: Union[Bool, NotImplemented]
    factory: Bool
    fileio: Bool
    float: Bool
    frameinfo: Bool
    frametype: Bool
    func: Optional[Callable]
    functiondef: Bool
    functiontype: Bool
    generator: Bool
    generatortype: Bool
    genericalias: Bool
    getitem: Bool
    getmethod: Bool
    getsetdescriptortype: Bool
    hashable: Bool
    import_ast: Bool
    importname: Str
    importfrom: Bool
    initvar: Bool
    installed: Union[Bool, NotImplemented]
    def instance(self, *args: Type) -> Bool: ...
    int: Bool
    io: Bool
    iterable: Bool
    iterator: Bool
    list_like: Bool
    lambda_ast: Bool
    lambdatype: Bool
    list: Bool
    lst: Bool
    mappingproxytype: Bool
    mappingproxytype_sub: Bool
    memberdescriptortype: Bool
    method: Bool
    methoddescriptor: Bool
    methoddescriptortype: Bool
    methodtype: Bool
    methodwrappertype: Bool
    methodwrappertype_sub: Bool
    missing: Bool
    missing_or_factory: Bool
    mlst: Bool
    mm: Bool
    moduletype: Bool
    namedtuple: Bool
    namedtupletyping: Bool
    noncomplex: Bool
    none: Bool
    object: Bool
    pathlib: Bool
    picklable: Bool
    primitive: Bool
    prop: Bool
    propany: Bool
    def readonly(self, name: Union[Str, nstr] = ...) -> Union[Bool, Exception]: ...
    reducible: Bool
    reducible_sequence_subclass: Bool
    routine: Bool
    sequence: Bool
    sequence_sub: Bool
    settype: Bool
    setter: Bool
    signature: Dict
    simple: Bool
    sized: Bool
    slotstype: Bool
    static: Bool
    str: Bool
    stringio: Bool
    def subclass(self, *args: Type) -> Bool: ...
    def supports(self, *args: Type) -> Bool: ...
    tracebacktype: Bool
    tuple: Bool
    type: Bool
    varstype: Bool
    wrapperdescriptortype: Bool
    def writeable(self, name: Union[Str, nstr]) -> Bool: ...
class MatchError(Exception):
    def __init__(self, *args, **kwargs) -> None: ...
class Missing:
    name: Final['MISSING']
    __slots__: TupleType = ...
    def __hash__(self) -> int: ...
    def __reduce__(self) -> tuple[Type[Missing], tuple]: ...
    def __repr__(self) -> str: ...
MISSING: Final[Missing()]
DictStrMissingAny = dict[str, Union[Missing, Any]]
class ModuleBase(EnumBase, metaclass=EnumBaseMeta):
    get: ModuleType = ...
    load: ModuleType = ...
class Module(ModuleBase):
    FUNCTOOLS = ...
    TYPING = ...
class nstr(str):
    name: str
    __slots__: TupleStr = ...
    def __new__(cls, value='', *args, **kwargs) -> nstr: ...
    def __init__(self, value='', *args, **kwargs) -> None: ...
    @overload
    def __call__(self, data: str = None) -> str: ...
    @overload
    def __call__(self, data: Any = None) -> bool: ...
    def get(self, obj: Any, default: Any = ...) -> Any: ...
    def getset(self, obj: Any, default: Any = ..., setvalue: bool = ...) -> Any: ...
    def has(self, obj: Any) -> bool: ...
    def hasget(self, obj: Any, default: Any = ...) -> Any: ...
    def hasgetany(self, obj: Any, default: Any = ...) -> Any: ...
    getter: getter
    def parse(self) -> NParser: ...
class _N(Generic[_T]):
    # Tuple - Attrs
    ABOUT: nstr = ...
    ABSTRACTMETHODS: nstr = ...
    AUTHOR: nstr = ...
    ADAPT: nstr = ...
    ALL: nstr = ...
    ALLOC: nstr = ...
    ANNOTATIONS: nstr = ...
    ARGS: nstr = ...
    ASDICT: nstr = ...
    ATTRIBUTES: nstr = ...
    BASE: nstr = ...
    BASICSIZE: nstr = ...
    BUILD_CLASS: nstr = ...
    BUILTINS: nstr = ...
    CACHE_CLEAR: nstr = ...
    CACHE_INFO: nstr = ...
    CACHED: nstr = ...
    CLASS: nstr = ...
    CODE: nstr = ...
    CONFORM: nstr = ...
    CONTAINS: nstr = ...
    CREDITS: nstr = ...
    COPY: nstr = ...
    COPYRIGHT: nstr = ...
    CVSID: nstr = ...
    DATACLASS_FIELDS: nstr = ...
    DATACLASS_PARAMS: nstr = ...
    DATE: nstr = ...
    DECIMAL_CONTEXT: nstr = ...
    DEEPCOPY: nstr = ...
    DELATTR: nstr = ...
    DICT: nstr = ...
    DICTOFFSET: nstr = ...
    DIR: nstr = ...
    DOC: nstr = ...
    DOCFORMAT: nstr = ...
    EMAIL: nstr = ...
    EQ: nstr = ...
    EXCEPTION: nstr = ...
    FILE: nstr = ...
    FLAGS: nstr = ...
    FUNC: nstr = ...
    GET: nstr = ...
    GETATTRIBUTE: nstr = ...
    GETFORMAT: nstr = ...
    GETINITARGS: nstr = ...
    GETITEM: nstr = ...
    GETNEWARGS: nstr = ...
    GETSTATE: nstr = ...
    HASH: nstr = ...
    HASH_EXCLUDE: nstr = ...
    IGNORE_ATTR: nstr = ...
    IGNORE_COPY: nstr = ...
    IGNORE_HASH: nstr = ...
    IGNORE_INIT: nstr = ...
    IGNORE_KWARG: nstr = ...
    IGNORE_REPR: nstr = ...
    IGNORE_STATE: nstr = ...
    IGNORE_STR: nstr = ...
    IMPORT: nstr = ...
    INIT: nstr = ...
    INIT_SUBCLASS: nstr = ...
    INITIALIZING: nstr = ...
    ISABSTRACTMETHOD: nstr = ...
    ITEMSIZE: nstr = ...
    LEN: nstr = ...
    LIBMPDEC_VERSION: nstr = ...
    LOADER: nstr = ...
    LTRACE: nstr = ...
    MAIN: nstr = ...
    MEMBERS: nstr = ...
    METHODS: nstr = ...
    MODULE: nstr = ...
    MP_MAIN: nstr = ...
    MRO: nstr = ...
    NAME: nstr = ...
    NEW: nstr = ...
    NEW_MEMBER: nstr = ...
    NEW_OBJ: nstr = ...
    NEW_OBJ_EX: nstr = ...
    OBJ_CLASS: nstr = ...
    OBJCLASS: nstr = ...
    PACKAGE: nstr = ...
    POST_INIT: nstr = ...
    PREPARE: nstr = ...
    QUALNAME: nstr = ...
    REDUCE: nstr = ...
    REDUCE_EX: nstr = ...
    REPR: nstr = ...
    REPR_EXCLUDE: nstr = ...
    REPR_NEWLINE: nstr = ...
    REPR_PPROPERTY: nstr = ...
    RETURN: nstr = ...
    SELF_CLASS: nstr = ...
    SETATTR: nstr = ...
    SETFORMAT: nstr = ...
    SETSTATE: nstr = ...
    SIGNATURE: nstr = ...
    SIZEOF: nstr = ...
    SLOTNAMES: nstr = ...
    SLOTS: nstr = ...
    SPEC: nstr = ...
    STATE: nstr = ...
    STATUS: nstr = ...
    STR: nstr = ...
    SUBCLASSHOOK: nstr = ...
    TEST: nstr = ...
    TEXT_SIGNATURE: nstr = ...
    THIS_CLASS: nstr = ...
    TRUNC: nstr = ...
    VERSION: nstr = ...
    WARNING_REGISTRY: nstr = ...
    WEAKREF: nstr = ...
    WEAKREFOFFSET: nstr = ...
    WRAPPED: nstr = ...
    _asdict: nstr = ...
    _cls: nstr = ...
    _copy: nstr = ...
    _count: nstr = ...
    _data: nstr = ...
    _extend: nstr = ...
    _external: nstr = ...
    _field_defaults: nstr = ...
    _field_type: nstr = ...
    _fields: nstr = ...
    _file: nstr = ...
    _filename: nstr = ...
    _frame: nstr = ...
    _func: nstr = ...
    _function: nstr = ...
    _get: nstr = ...
    _globals: nstr = ...
    _id: nstr = ...
    _index: nstr = ...
    _ip: nstr = ...
    _item: nstr = ...
    _items: nstr = ...
    _key: nstr = ...
    _keys: nstr = ...
    _kind: nstr = ...
    _locals: nstr = ...
    _name: nstr = ...
    _node: nstr = ...
    _origin: nstr = ...
    _obj: nstr = ...
    _object: nstr = ...
    _path: nstr = ...
    _repo: nstr = ...
    _RV: nstr = ...
    _rv: nstr = ...
    _pypi: nstr = ...
    _remove: nstr = ...
    _reverse: nstr = ...
    _sort: nstr = ...
    _source: nstr = ...
    _update: nstr = ...
    _value: nstr = ...
    _values: nstr = ...
    _vars: nstr = ...
    add: nstr = ...
    append: nstr = ...
    args: nstr = ...
    asdict: nstr = ...
    attr: nstr = ...
    attrs: nstr = ...
    authorized_keys: nstr = ...
    backup: nstr = ...
    cls: nstr = ...
    clear: nstr = ...
    cli: nstr = ...
    co_name: nstr = ...
    code_context: nstr = ...
    compare: nstr = ...
    copy: nstr = ...
    copyright: nstr = ...
    count: nstr = ...
    credits: nstr = ...
    data: nstr = ...
    default: nstr = ...
    default_factory: nstr = ...
    defaults: nstr = ...
    docs: nstr = ...
    endswith: nstr = ...
    exit: nstr = ...
    extend: nstr = ...
    external: nstr = ...
    f_back: nstr = ...
    f_code: nstr = ...
    f_globals: nstr = ...
    f_lineno: nstr = ...
    f_locals: nstr = ...
    file: nstr = ...
    filename: nstr = ...
    frame: nstr = ...
    func: nstr = ...
    function: nstr = ...
    get: nstr = ...
    globals: nstr = ...
    hash: nstr = ...
    help: nstr = ...
    id: nstr = ...
    id_rsa: nstr = ...
    ignore: nstr = ...
    index: nstr = ...
    init: nstr = ...
    ip: nstr = ...
    item: nstr = ...
    items: nstr = ...
    kali: nstr = ...
    key: nstr = ...
    keys: nstr = ...
    kind: nstr = ...
    kwarg: nstr = ...
    kwargs: nstr = ...
    kwargs_dict: nstr = ...
    license: nstr = ...
    lineno: nstr = ...
    locals: nstr = ...
    metadata: nstr = ...
    name: nstr = ...
    node: nstr = ...
    obj: nstr = ...
    object: nstr = ...
    origin: nstr = ...
    path: nstr = ...
    pop: nstr = ...
    popitem: nstr = ...
    public: nstr = ...
    pypi: nstr = ...
    PYPI: nstr = ...
    quit: nstr = ...
    remove: nstr = ...
    repo: nstr = ...
    REPO: nstr = ...
    repr: nstr = ...
    rv: nstr = ...
    reverse: nstr = ...
    scripts: nstr = ...
    search: nstr = ...
    self: nstr = ...
    sort: nstr = ...
    source: nstr = ...
    SOURCE: nstr = ...
    startswith: nstr = ...
    templates: nstr = ...
    test: nstr = ...
    tests: nstr = ...
    tb_frame: nstr = ...
    tb_lineno: nstr = ...
    tb_next: nstr = ...
    tmp: nstr = ...
    type: nstr = ...
    ubuntu: nstr = ...
    update: nstr = ...
    value: nstr = ...
    values: nstr = ...
    values_dict: nstr = ...
    vars: nstr = ...
    venv: nstr = ...
    # Dict 4 - Environment
    AMARILLO: str = ...
    ANSIBLE: str = ...
    ANSIBLE_SUDO_PASSWORD: str = ...
    APPLICATIONS: str = ...
    ATHENS_GONOSUM_PATTERNS: str = ...
    AZUL: str = ...
    AZULCLARO: str = ...
    BAPY: str = ...
    BASH_RC_DIR: str = ...
    BASH_RC_NAME: str = ...
    BASH_RC_PATH: str = ...
    BASH_RC_PROJECT: str = ...
    BREW: str = ...
    BREWFILE: str = ...
    CACHES: str = ...
    CLONES: str = ...
    CLT: str = ...
    CONFLUENCE_SERVER_PASS: str = ...
    DARWIN: str = ...
    DATA: str = ...
    DEBIAN: str = ...
    DEFAULT_CA_BUNDLE_PATH: str = ...
    DEFAULT_KALI_USER: str = ...
    DEVOPS_HOST: str = ...
    DEVOPS_SLD: str = ...
    DOCK: str = ...
    DOCKER_HOST: str = ...
    DOMAINED_DIR: str = ...
    DOMAINED_PATH: str = ...
    EDITOR: str = ...
    EXAMPLES: str = ...
    FILES: str = ...
    GEMFILE: str = ...
    GEOLOCATION_KEY: str = ...
    GITHUB_DESKTOP: str = ...
    GITHUB_DESKTOP_PROCESS: str = ...
    GITHUB_DOMAIN: str = ...
    GITHUB_EMAIL: str = ...
    GITHUB_ORGANIZATION: str = ...
    GITHUB_ORGANIZATION_CLONE_PREFIX_HTTP: str = ...
    GITHUB_ORGANIZATION_CLONE_PREFIX_SSH: str = ...
    GITHUB_ORGANIZATION_EMAIL: str = ...
    GITHUB_ORGANIZATION_ID: str = ...
    GITHUB_ORGANIZATION_ID_CLONE_PREFIX_SSH: str = ...
    GITHUB_ORGANIZATION_PASSWORD: str = ...
    GITHUB_ORGANIZATION_USERNAME: str = ...
    GITHUB_PRIVATE_URL: str = ...
    GITHUB_SECRETS_PATH: str = ...
    GITHUB_SECRETS_URL: str = ...
    GITHUB_URL: str = ...
    GITHUB_USERNAME: str = ...
    GIT_COMMAND: str = ...
    GIT_PREFIX: str = ...
    GIT_STORE: str = ...
    GO111MODULE: str = ...
    GOHOME: str = ...
    GOPATH: str = ...
    HOME: str = ...
    ICLOUD: str = ...
    ICLOUD_BASENAME: str = ...
    ICLOUD_NICK: str = ...
    INFOPATH: str = ...
    INTERNET: str = ...
    INTERNET_HASH: str = ...
    INVERSO: str = ...
    JETBRAINS: str = ...
    JETBRAINS_NAME: str = ...
    KALI: str = ...
    KEYNOTE: str = ...
    LANG: str = ...
    LATEST: str = ...
    LC_ALL: str = ...
    LIBRARY: str = ...
    LIBRARY_NICK: str = ...
    LOG: str = ...
    LOGNAME: str = ...
    LOG_BASENAME: str = ...
    MACDEV: str = ...
    MACDEV_BASENAME: str = ...
    MACDEV_NICK: str = ...
    MACKUP_ENGINE: str = ...
    MACROOT: str = ...
    MNOPI: str = ...
    MOBILE: str = ...
    MORADO: str = ...
    MSF_DATABASE_CONFIG: str = ...
    NPM: str = ...
    NPMFILE: str = ...
    NUMBERS: str = ...
    OPAMFILE: str = ...
    ORG: str = ...
    ORG_ATLAS_PASSWORD: str = ...
    ORG_BASENAME: str = ...
    ORG_GROUP_DEFAULT: str = ...
    ORG_HOST: str = ...
    ORG_SERVER: str = ...
    ORG_SLD: str = ...
    PACKAGES: str = ...
    PACKAGES_BASENAME: str = ...
    PAGES: str = ...
    PASSWD_PATH: str = ...
    PASSWORD: str = ...
    PATH: str = ...
    PEN: str = ...
    PEN_GIT: str = ...
    PEN_NICK: str = ...
    PREFS: str = ...
    PYCHARM: str = ...
    PYCHARM_NAME: str = ...
    PYCHARM_OPTIONS: str = ...
    PYCHARM_PLUGINS: str = ...
    PYCHARM_SCRATCHES: str = ...
    PYCHARM_VERSION: str = ...
    PYTHON39: str = ...
    PYTHON39_HOME: str = ...
    PYTHON39_PACKAGES: str = ...
    PYTHONASYNCIODEBUG: str = ...
    PYTHONDONTWRITEBYTECODE: str = ...
    PYTHONNOUSERSITE: str = ...
    PYTHONUNBUFFERED: str = ...
    REALNAME: str = ...
    REPO_DEFAULT_ADMIN_PASSWORD: str = ...
    REPO_DEFAULT_ADMIN_USERNAME: str = ...
    REPO_DEFAULT_API_URL: str = ...
    REPO_DEFAULT_API_VERSION: str = ...
    REPO_DEFAULT_HOST: str = ...
    REPO_DEFAULT_HOSTNAME: str = ...
    REPO_DEFAULT_PASSWORD: str = ...
    REPO_DEFAULT_SCHEME: str = ...
    REPO_DEFAULT_URL: str = ...
    REPO_DEFAULT_USERNAME: str = ...
    REQUESTS_CA_BUNDLE: str = ...
    REQUIREMENTS: str = ...
    ROJO: str = ...
    SAVED: str = ...
    SCALEWAY_ACCESS_KEY: str = ...
    SCALEWAY_ENDPOINT: str = ...
    SCALEWAY_ORGANIZATION_ID: str = ...
    SCALEWAY_SECRET_KEY: str = ...
    SCHEME: str = ...
    SCRATCHES: str = ...
    SCRATCHES_NAME: str = ...
    SCRIPTS: str = ...
    SCRIPTS_BASENAME: str = ...
    SCW_TOKEN: str = ...
    SECRETS_PATH: str = ...
    SECRETS_REPO: str = ...
    SERVERS: str = ...
    SERVERS_HOST: str = ...
    SERVERS_SLD: str = ...
    SHELL: str = ...
    SHELLCHECK_OPTS: str = ...
    SHLVL: str = ...
    SSH_AUTH_SOCK: str = ...
    SSH_PRIVATE_KEY: str = ...
    SSL_CERT_FILE: str = ...
    SUPPORT: str = ...
    SYNTHETIC: str = ...
    TERM: str = ...
    TERM_PROGRAM: str = ...
    TMPDIR: str = ...
    UBUNTU: str = ...
    USB: str = ...
    USER: str = ...
    USERFILE: str = ...
    USERHOME: str = ...
    USERNAME: str = ...
    VERDE: str = ...
    VIRTUAL_ENV: str = ...
    VISUAL: str = ...
    VULTR_API_KEY: str = ...
    VULTR_API_TIMEOUT: str = ...
    XPC_SERVICE_NAME: str = ...
    __slots__: TupleStr = ...
    @classmethod
    def _dict_(cls) -> dict[str, Union[nstr, Any]]: ...
    _dict_: dict[str, Union[nstr, Any]]
    def __repr__(self) -> str: ...
    @classmethod
    def BUILTIN_OTHER(cls) -> Tuple[nstr, ...]: ...
    @classmethod
    def MROITEMS(cls) -> dict[nstr, TupleStr]: ...
    @classmethod
    def SIGNATURES(cls) -> dict[nstr, nstr]: ...
    def __class_getitem__(cls, item: Any) -> Union[nstr, Any]: ...
N: Union[_N, type, Type[_N], Type] = ...
class NameAttr(metaclass=abc.ABCMeta):
    __slots__: TupleStr = ...
    name: str = ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class Namedtuple(metaclass=abc.ABCMeta):
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
    @abc.abstractmethod
    def _asdict(self) -> DictStrAny: ...
    _fields: TupleStr
    _field_defaults: DictStrAny
class NamedTupleTyping(metaclass=abc.ABCMeta):
    __annotations__: DictStrAny
    _fields: TupleStr
    _field_defaults: DictStrAny
    def _asdict(self) -> DictStrAny: ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class NParser:
    data: str
    default: Any
    __slots__: TupleStr = ...
    def __init__(self, data: str = '', default: Any = None) -> None: ...
    def __repr__(self): ...
    def asdict(self): ...
    domain: Union[furl.furl, Any]
    email: Union[furl.furl, Any]
    environ: Union[furl.furl, str, IPv, int, pathlib.Path, Any]
    integer: Union[int, Any]
    ip: Union[IPv, Any]
    log_level: Union[str, Any]
    log_value: Union[int, Any]
    path: Union[pathlib.Path, Any]
    true: Union[bool, Any]
    url: Union[furl.furl, Any]
ObjBase = NamedTuple('ObjBase', c=Class, data=Any)
class Obj(ObjBase):
    cache: dict[tuple[TypesType, Callable], DictStrAny] = ...
    __slots__ = ()
    def __new__(cls, data: Any) -> Obj: ...
    def __iter__(self) -> Iterator[Str]: ...
    @property
    def deepcopy(self) -> Any: ...
    def hash(self, access: Access = ..., prop: bool = ...) -> DictStrAny: ...
    def init(self, access: Access = ...) -> DictStrAny: ...
    @property
    def pickles(self) -> Optional[bytes]: ...
    def repr(self, access: Access = ..., both: bool = ..., prop: bool = ...) -> DictStrAny: ...
    def state(self) -> DictStrAny: ...
    @property
    def state_methods(self) -> Any: ...
    @property
    def unpickles(self) -> Any: ...
    def vars(self, access: Access = ..., both: bool = ..., ignore: Callable = ...,
             state: bool = ..., prop: bool = ...) -> DictStrAny: ...
class PIs(EnumBase, metaclass=EnumBaseMeta):
    DIR = ...
    FILE = ...
class PMode(EnumBase, metaclass=EnumBaseMeta):
    DIR = ...
    FILE = ...
    X = ...
class POption(EnumBase, metaclass=EnumBaseMeta):
    BOTH = ...
    DIRS = ...
    FILES = ...
class POutput(EnumBase, metaclass=EnumBaseMeta):
    BOTH = ...
    BOX = ...
    DICT = ...
    LIST = ...
    NAMED = ...
    TUPLE = ...
class PSuffixBase(EnumBase, metaclass=EnumBaseMeta):
    def _generate_next_value_(self: Union[str, Callable[..., str]], *args) -> str: ...
class PSuffix(PSuffixBase):
    NO = ...
    BASH = ...
    ENV = ...
    GIT = ...
    INI = ...
    J2 = ...
    JINJA2 = ...
    LOG = ...
    MONGO = ...
    OUT = ...
    PY = ...
    RLOG = ...
    SH = ...
    SHELVE = ...
    SSH = ...
    TOML = ...
    YAML = ...
    YML = ...
class Path(pathlib.Path, pathlib.PurePosixPath, Generic[_Path], str):
    __slots__: TupleStr = ...
    _previous: Path
    _rv: Union[Path, FindUp, Any]
    endseparator: str
    find_packages: list
    installed: Path
    installedbin: Path
    installedpy: Path
    parents: Sequence[Path] = ...
    parent: Path = ...
    pwd: Path
    resolved: Path
    source: str
    stemfull: Path
    str: str
    text: str
    to_modname: Optional[str]
    to_module: Optional[Union[ModuleType, AllAttr]]
    def __new__(cls: Type[Path], *args: PathLikeStr, **kwargs: Any) -> Path: ...
    def __call__(self, name: Optional[str] = ..., file: bool = ...,
                 group: Optional[Union[str, int]] = ...,
                 mode: Optional[Union[int, str]] = ..., su: bool = ...,
                 u: Optional[Union[str, int]] = ...) -> Path: ...
    def __contains__(self, value: Iterable[str]) -> bool: ...
    def __eq__(self, other: Union[PathLikeStr, tuple[str]]) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: PathLikeStr) -> bool: ...
    def __le__(self, other: PathLikeStr) -> bool: ...
    def __gt__(self, other: PathLikeStr) -> bool: ...
    def __ge__(self, other: PathLikeStr) -> bool: ...
    def __truediv__(self, key: PathLikeStr) -> Path: ...
    def __rtruediv__(self, key: PathLikeStr) -> Path: ...
    def _is_file(self) -> Optional[str]: ...
    def absolute(self) -> Path: ...
    def append_text(self, data, encoding=None, errors=None): ...
    def c_(self, p: Any = ...) -> Path: ...
    @property
    @contextlib.contextmanager
    def cd(self) -> Path: ...
    @classmethod
    def cwd(cls: Type[Path]) -> Path: ...
    def chdir(self): ...
    def chmod(self, mode: Optional[Union[int, str]] = ...) -> Path: ...
    def chown(self, group: Optional[Union[str, int]] = ...,
              u: Optional[Union[str, int]] = ...) -> Path: ...
    def expanduser(self) -> Path: ...
    def fd(self, flags: int, mode: int = ..., *, dir_fd: Optional[int] = ...) -> int: ...
    def find_up(self, file: PIs = ..., name: Union[str, PSuffix] = ..., uppermost: bool = ...) -> FindUp: ...
    @classmethod
    def from_obj(cls, obj: Any) -> Path: ...
    def glob(self, pattern: str) -> Generator[Path, None, None]: ...
    def has(self, value: str) -> bool: ...
    @classmethod
    def home(cls, name: str = ..., file: bool = ...) -> Path: ...
    @classmethod
    def internal(cls) -> PathInternal: ...
    def j2(self, dest: Any = ..., stream: bool = ..., variables: dict = ...) -> Union[list, dict]: ...
    def joinpath(self, *other: PathLikeStr) -> Path: ...
    def iterdir(self) -> tuple[Path, None, None]: ...
    def mkdir(self, name: Optional[str] = ..., group: Optional[Union[str, int]] = ...,
              mode: Optional[Union[int, str]] = ..., su: bool = ...,
              u: Optional[Union[str, int]] = ...) -> Path: ...
    def open(self, mode: str = ..., buffering: int = ..., encoding: str = ..., errors: str = ..., newline: str = ...,
             token: bool = ...) -> Optional[OpenIO]: ...
    def path(self, uppermost: bool = ...) -> Path: ...
    def read(self, encoding: Optional[str] = ..., errors: Optional[str] = ..., lnum: bool = False,
             token: bool = ...) -> Optional[Union[str, tuple[str, int]]]: ...
    def read_text(self, encoding: Optional[str] = ..., errors: Optional[str] = ...,
                  token: bool = ...) -> Optional[str]: ...
    def readlink(self) -> Path: ...
    def relative(self, p: Any) -> Path: ...
    def relative_to(self, *other: PathLikeStr) -> Path: ...
    def rename(self, target: PathLikeStr) -> Path: ...
    def replace(self, target: PathLikeStr) -> Path: ...
    def resolve(self, strict: bool = ...) -> Path: ...
    def rglob(self, pattern: str) -> typing.Generator[Path, None, None]: ...
    def rm(self, missing_ok=...): ...
    def root(self, uppermost=True): ...
    def rv(self, default: Any = ...) -> Union[Path, FindUp, Any]: ...
    def samefile(self, other_path: Union[str, bytes, int, Path]) -> bool: ...
    def scan(self, option: POption = ...,
             output: POutput = ..., suffix: PSuffix = ...,
             level: bool = ..., hidden: bool = ..., frozen: bool = ...) -> Union[dict, list]: ...
    @classmethod
    @overload
    def shelve(cls, path: PathLikeStr = ..., register: bool = ..., rm: bool = ...) -> DbfilenameShelf: ...
    @classmethod
    @overload
    def shelve(cls, path: PathLikeStr = ..., pathonly: bool = ...) -> Path: ...
    @classmethod
    @contextlib.contextmanager
    def shelvectx(cls, path: PathLikeStr = ..., rm: bool = ...) -> DbfilenameShelf: ...
    def symlink_to(self, target: Union[str, Path], target_is_directory: bool = ...) -> None: ...
    @classmethod
    def sys(cls) -> Path: ...
    def templates(self, stream: bool = ...) -> dict[str, Union[jinja2.Template.stream, jinja2.Template.render]]: ...
    @classmethod
    @contextlib.contextmanager
    def tmp(cls) -> Path: ...
    def to_modules(self, suffix: bool = ..., uppermost: bool = ...) -> str: ...
    @classmethod
    def to_parent(cls, path: PathLikeStr = ...) -> Path: ...
    def touch(self, name: Optional[str] = ..., group: Optional[Union[str, int]] = ...,
              mode: Optional[Union[int, str]] = ..., su: bool = ...,
              u: Optional[Union[str, int]] = ...) -> Path: ...
    def with_name(self, name: str) -> Path: ...
    def with_stem(self, stem: str) -> Path: ...
    def with_suffix(self, suffix: str) -> Path: ...
class PathGit(EnumBase, metaclass=EnumBaseMeta):
    PATH =  ...
    ORIGIN =  ...
    ORGANIZATION =  ...
    def cmd(self, path: PathLikeStr = ...) -> Optional[Union[Path, furl]]: ...
    @classmethod
    def top(cls, path: PathLikeStr = ...) -> GitTop: ...
class PathInstallScript(setuptools.command.install.install):
    def run(self): ...
    @classmethod
    def path(cls) -> str: ...
class Re(EnumBase, metaclass=EnumBaseMeta):
    ASYNCDEF = ...
    BLOCK = ...
    DEF = ...
    DECORATOR = ...
    ENVVAR = ...
    HEXSHA_ONLY = ...
    HEXSHA_SHORTENED = ...
    LAMBDA = ...
    LETTERS = ...
    LETTERS_NUMBERS = ...
    MODULE_IDENTIFIER = ...
    NUMBERS = ...
    TAB_FULL_LINE = ...
    UNDERSCORES_PREFIX = ...
    UNDERSCORES_SUFFIX = ...
    VAR = ...
    VAR_DASH = ...
    WHITESPACE = ...
    ALL = ...
    PRIVATE = ...
    PROTECTED = ...
    PUBLIC = ...
class ReposNamesBase:
    __slots__: TupleStr = ...
    name: str
    script: str
    def __init__(self, name: str = ..., script: str = ...) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __reduce__(self)-> tuple[Type[getter], TupleStr]: ...
class ReposNames(dict, typing.MutableMapping[_KT, ReposNamesBase], typing.Mapping[_KT, ReposNamesBase]):
    rccmd: ReposNamesBase
    rcdev: ReposNamesBase
    rclib: ReposNamesBase
    rctest: ReposNamesBase
    rcutils: ReposNamesBase
    rcvars: ReposNamesBase
    __slots__: TupleStr = ...
    def __init__(self) -> None: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
class SlotsType(metaclass=abc.ABCMeta):
    __slots__: TupleStr = ...
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...
class SourceVars:
    file: Optional[Path]
    globs: DictStrAny
    locs: DictStrAny
    name: Optional[str]
    package: Optional[str]
    spec: ModuleSpec
    repo: Optional[str]
    pypi: Optional[str]
    source: Optional[Source]
    vars: DictStrAny
    __sourcevars__ = dict[str, str]
    __slots__: TupleStr
    def __init__(self, frame: FrameType = ...) -> None: ...
    def __eq__(self, other: SourceVars): ...
    def __getitem__(self, item: str) -> Any: ...
    def __getstate__(self) -> DictStrAny: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: DictStrAny) -> SourceVars: ...
    @overload
    def get(self, item: str) -> Any: ...
    @overload
    def get(self, item: str, default: Type[None] = ...) -> Any: ...
SourceBase = NamedTuple('SourceBase', code=Optional[CodeType], data=Union[FrameType, Any], exists=bool,
                        file=Optional[Path], function=str, include=bool, internal=bool, lineno=int, module=bool,
                        node=Union[ast.AST, AsyncsUnion, DefsUnion], source=Union[str, list[str, int]],
                        vars=SourceVars)
class Source(SourceBase):
    EXCLUDE_DIRS: TupleStr = ...
    __slots__: TupleStr = ...
    def __new__(cls, data, **kwargs: Any) -> Source: ...
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
    args: DictStrAny = ...
class StateEnv(environs.Env, BaseState):
    def __init__(self, *, eager: bool = ..., expand_vars: bool = ...): ...
class UserActual:
    ROOT: bool = ...
    SUDO: bool = ...
    SUDO_USER: str = ...
    id: int = ...
    gecos: str = ...
    gid: int = ...
    gname: str = ...
    home: pathlib.Path = ...
    name: str = ...
    passwd: pwd.struct_passwd = ...
    shell: pathlib.Path = ...
    ssh: pathlib.Path = ...
    auth_keys: pathlib.Path = ...
    id_rsa: pathlib.Path = ...
    id_rsa_pub: pathlib.Path = ...
    git_config_path: pathlib.Path = ...
    def __init__(self) -> None: ...
class UserProcess:
    id: int = ...
    gecos: str = ...
    gid: int = ...
    gname: str = ...
    home: pathlib.Path = ...
    name: str = ...
    passwd: pwd.struct_passwd = ...
    ROOT: bool = ...
    shell: pathlib.Path = ...
    ssh: pathlib.Path = ...
    SUDO: bool = ...
    SUDO_USER: str = ...
    auth_keys: pathlib.Path = ...
    id_rsa: pathlib.Path = ...
    id_rsa_pub: pathlib.Path = ...
    git_config_path: pathlib.Path = ...
    git_config: git.GitConfigParser = ...
    github_username: str = ...
class User:
    actual: UserActual = ...
    process: UserProcess = ...
    gecos: str = ...
    gid: int = ...
    gname: str = ...
    home: pathlib.Path = ...
    id: int = ...
    name: str = ...
    passwd: pwd.struct_passwd = ...
    ROOT: bool = ...
    shell: pathlib.Path = ...
    ssh: pathlib.Path = ...
    SUDO: bool = ...
    SUDO_USER: str = ...
    auth_keys: pathlib.Path = ...
    id_rsa: pathlib.Path = ...
    id_rsa_pub: pathlib.Path = ...
    git_config_path: pathlib.Path = ...
    git_config: git.GitConfigParser = ...
    github_username: str = ...
    shelve: pathlib.Path = ...
    GIT_SSH_COMMAND: str = ...
    def __contains__(self, item: Union[User, str]) -> bool: ...
    def __eq__(self, other: User) -> bool: ...
    def __hash__(self) -> int: ...
    @staticmethod
    def sudo(command, su: bool = ...) -> str: ...
class VarsType(metaclass=abc.ABCMeta):
    __dict__: DictStrAny
    @classmethod
    def __subclasshook__(cls, C: Type) -> bool: ...

# Dependant
FindUp = NamedTuple('FindUp', path=Optional[Path], previous=Optional[Path])
class Frame(Generic[_T]):
    cache: dict[Path, Frame]
    # Coro = NamedTuple('Coro', func=bool, line=bool, value=bool)
    class Coro(TypedDict):
        func: bool
        line: bool
    class Line(TypedDict):
        coro: Frame.Coro
        nodes: list[typing.Union[ast.AST, AsyncsUnion, DefsUnion]]
        source: str
    _args: Optional[DictStrAny]
    args: DictStrAny
    cls: Optional[str]
    code: CodeType
    context: Optional[list[str, ...]]
    coro: bool
    decorator: list[str, ...]
    external: bool
    file: Path
    frame: FrameType
    function: str
    functions: intervaltree.IntervalTree
    include: bool
    internal: bool
    lineno: int
    lines: dict[int, Line]
    module: bool
    node: Union[ast.AST, AsyncsUnion, DefsUnion, ast.stmt, ast.Import, ast.ImportFrom]
    real: Optional[int]
    qualname: Optional[str]
    source: Optional[str]
    _vars: Optional[SourceVars]
    vars: SourceVars
    __slots__: TupleStr = ...
    def __init__(self, frame: FrameType) -> None: ...
    def __add__(self, node: Union[ast.AST, AsyncsUnion, DefsUnion, ast.stmt]) -> Optional[bool]: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[Union[ast.AST, AsyncsUnion, DefsUnion, ast.stmt, ast.Import, ast.ImportFrom]]: ...
    def __reduce__(self) -> Tuple[Type[Is], Tuple]: ...
    def __repr__(self) -> Str: ...
    def __class_getitem__(cls, item: Any) -> GenericAlias: ...
FrameIdBase = NamedTuple('FrameIdBase', code=str, decorator=Union[list, str], function=str, parts=Union[list, str],
                         real=Optional[int], coro=bool)
class FrameId(EnumBase, metaclass=EnumBaseMeta):
    ASYNCCONTEXTMANAGER = ...
    IMPORTLIB = ...
    RUN = ...
    TO_THREAD = ...
    # FUNCDISPATCH = ('return funcs[Call().ASYNC]', 'wrapper bapy', 'core', 1)
FrameSimple = NamedTuple('FrameSimple', back=FrameType, code=CodeType,
                         frame=FrameType, function=str,
                         globals=DictStrAny, lineno=int, locals=DictStrAny, name=str,
                         package=str, path=Path, vars=DictStrAny)
GitTop = NamedTuple('GitTop', name=str, origin=furl, path=Path)
PathLikeStr = Union[os.PathLike, Path, str]
PathInternal = NamedTuple('PathInternal', file=Path, path=Path, package=str)
path_internal: PathInternal
SYSCONFIG_PATHS_EXCLUDE: tuple[Path, ...]
PATHS_EXCL: tuple[Path]
Real = NamedTuple('Real', caller=Frame, real=Optional[Frame])
class Stack(tuple[Frame]):
    real: Optional[Frame]
    def __new__(cls, init: bool = ...) -> Stack[Frame]: ...
    def __call__(self, index: int = ..., real: bool = ...) -> Union[Frame, Real]: ...
    def __repr__(self) -> str: ...
    @classmethod
    def init(cls) -> Stack[Frame]: ...
    @classmethod
    def main(cls) -> Frame: ...
    @classmethod
    def package(cls) -> Frame: ...
Types = Union[AllAttr, AnnotationsAttr, AsDictMethod, AsDictProperty, DataClass,
                     GetItem, GetMethod,
                     NameAttr, Namedtuple, NamedTupleTyping, VarsType, SlotsType]
TypesType = Union[Type[Any], Type[AllAttr], Type[AnnotationsAttr],
                         Type[AsDictMethod], Type[AsDictProperty],
                         Type[DataClass],
                         Type[GetItem], Type[GetMethod],
                         Type[NameAttr], Type[Namedtuple], Type[NamedTupleTyping],
                         Type[VarsType], Type[SlotsType]]
# Echo
def black(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def blue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def cyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def green(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def magenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def red(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
        blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def white(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def yellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bblack(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bblue(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bcyan(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
          blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bgreen(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bmagenta(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
             blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bred(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
         blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def bwhite(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
           blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
def byellow(msg: Any, bold: bool = ..., nl: bool = ..., underline: bool = ...,
            blink: bool = ..., err: bool = ..., reset: bool = ..., rc: Optional[int] = ...) -> None: ...
# Instances
alocks: dd[Union[typing.Hashable, Path, str], asyncio.Lock] = ...
locks: dd[Union[typing.Hashable, Path, str], LockClass] = ...
reposnames: ReposNames = ...
user: User = ...
init_stack: list[inspect.FrameInfo]
