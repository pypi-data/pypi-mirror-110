from collections import deque, OrderedDict
from spydrnet.ir.port import Port
from spydrnet.ir.cable import Cable
import spydrnet.parsers.verilog.verilog_tokens as vt


class Composer:

    def __init__(self):
        self.file = None
        self.direction_string_map = dict()
        self.direction_string_map[Port.Direction.IN] = "input"
        self.direction_string_map[Port.Direction.OUT] = "output"
        self.direction_string_map[Port.Direction.INOUT] = "inout"
        self.direction_string_map[Port.Direction.UNDEFINED] = "/* undefined port direction */ inout"
        self.written = set()
        self.indent_count = 4  # set the indentation level for various components

    def run(self, ir, file_out="out.v"):
        self._open_file(file_out)
        self._compose(ir)

    def _open_file(self, file_name):
        f = open(file_name, "w")
        self.file = f

    def _compose(self, netlist):
        self._write_header(netlist)
        instance = netlist.top_instance
        if instance is not None:
            self._write_from_top(instance)
        for library in netlist.libraries:
            for definition in library.definitions:
                if definition not in self.written:
                    self._write_module(definition)

    def _write_header(self, netlist):
        self.file.write("//Generated from netlist by SpyDrNet\n")
        self.file.write("//netlist name: " + netlist.name + "\n")

    # def _write_header(self, netlist):
    #     self.file.write("////////////////////////////////////////\n")
    #     self.file.write("//File generated by SpyDrNet\n")
    #     if netlist.name is not None:
    #         self.file.write("//Netlist: " + netlist.name + "\n")
    #     self.file.write("////////////////////////////////////////\n")
    #     if netlist.top_instance is None:
    #         print("WARNING: Netlist has no top instance. Empty file written")
    #         self.file.write("//top instance is none.\n")

    def _write_from_top(self, instance):
        #self.written = set()
        to_write = deque()
        to_write.append(instance.reference)
        while(len(to_write) != 0):
            definition = to_write.popleft()
            if definition in self.written:
                continue
            self.written.add(definition)
            for c in definition.children:
                if c.reference not in self.written:
                    to_write.append(c.reference)
            assert definition.name is not None, self._error_string(
                "definition has no name set", definition)
            self._write_module(definition)

    # def _write_definition_single(self, definition):
    #     if definition.library.name == "SDN_VERILOG_ASSIGNMENT":
    #         #no need to write assignment definitions.
    #         return
    #     need_end_primitive = False
    #     #if "VERILOG.primitive" in definition and definition["VERILOG.primitive"] == True:
    #     if definition.library.name == "SDN.verilog_primitives":
    #         need_end_primitive = True
    #         self.file.write("`celldefine\n")
    #     # else:
    #     self.file.write("module ")

    #     self._write_escapable_name(definition.name)
    #     self.file.write("\n")
    #     self._write_ports(definition)

    #     for c in definition.cables:
    #         self._write_cable(c)

    #     for i in definition.children:
    #         if i.reference.library.name == "SDN_VERILOG_ASSIGNMENT":
    #             self._write_assignments(i)
    #         else:
    #             self._write_instanciation(i)

    #     # for c in definition.cables:
    #     #     self._write_assignments(c)

    #     self.file.write("endmodule\n")
    #     if need_end_primitive:
    #         self.file.write("`endcelldefine\n")

    # def _get_wire_indicies_in_cable(self, wire):
    #     '''return the index of the given wire'''
    #     cable = wire.cable
    #     return cable.wires.index(wire) + cable.lower_index

    # def _get_assignment_cable_indicies_from_port(self, port, instance):
    #     '''get the cable associated with the outer pins on the instance's port.'''

    #     right_pin = port.pins[0]
    #     left_pin = port.pins[-1]
    #     right_pin = instance.pins[right_pin]
    #     left_pin = instance.pins[left_pin]

    #     left_wire = left_pin.wire
    #     right_wire = right_pin.wire
    #     assert left_wire.cable == right_wire.cable

    #     if not left_wire.cable.is_downto:
    #         temp = right_wire
    #         right_pin = left_wire
    #         left_wire = temp

    #     left = self._get_wire_indicies_in_cable(left_wire)
    #     right = self._get_wire_indicies_in_cable(right_wire)

    #     name = left_wire.cable.name

    #     cable = left_wire.cable

    #     if max(left,right) == (cable.lower_index + len(cable.wires) - 1) and min(left, right) == cable.lower_index:
    #         left = None
    #         right = None
    #     elif left == right:
    #         left = None

    #     return name, left, right

    # def _get_assignment_indicies(self, instance):
    #     '''it should only be one cable per assignment port the instance must also be an assignment instance'''
    #     definition = instance.reference
    #     in_port = next(definition.get_ports("i"), None)
    #     assert in_port != None
    #     out_port = next(definition.get_ports("o"), None)
    #     assert out_port != None

    #     cable_in_name, in_left, in_right = self._get_assignment_cable_indicies_from_port(in_port, instance)
    #     cable_out_name, out_left, out_right = self._get_assignment_cable_indicies_from_port(out_port, instance)

    #     return cable_in_name, cable_out_name, in_left, in_right, out_left, out_right

    # def _write_assignment_single_cable(self, cable_name, low, high):
    #     self._write_escapable_name(cable_name)
    #     if high != None:
    #         self.file.write("[")
    #         self.file.write(str(high))
    #         if low!=None:
    #             self.file.write(":")
    #             self.file.write(str(low))
    #         self.file.write("]")

    # def _write_assignments(self, instance):
    #     cable_in_name, cable_out_name, in_low, in_high, out_low, out_high = self._get_assignment_indicies(instance)
    #     self.file.write("assign ")
    #     self._write_assignment_single_cable(cable_out_name, out_low, out_high)
    #     self.file.write(" = ")
    #     self._write_assignment_single_cable(cable_in_name, in_low, in_high)
    #     self.file.write(";\n")

    # def _write_ports(self, definition):
    #     '''write all ports in the netlist. needs to take into account port aliasing as well'''
    #     self._write_header_ports(definition)
    #     self._write_port_list(definition)

    # def _write_header_ports(self, definition):
    #     self.file.write("(")
    #     first = "\n    "
    #     for p in definition.ports:
    #         cables = self._get_cable_list_from_port(p)
    #         self.file.write(first)
    #         if len(cables) == 0 or (len(cables) == 1 and cables.pop().name == p.name):
    #             self._write_escapable_name(p.name)
    #         else:
    #             wires = self._get_wires_list_from_port(p)
    #             self.file.write(".")
    #             self._write_escapable_name(p.name)
    #             self.file.write("({")
    #             between = ""
    #             for w in wires:
    #                 self.file.write(between)
    #                 if w is not None:
    #                     self._write_escapable_name(w.cable.name)
    #                     index = self._get_wire_indicies_in_cable(w)
    #                     self.file.write("[" + str(index) + "]")
    #                 between = ", "
    #             self.file.write("})")

    #         first = ",\n    "
    #     self.file.write("\n);\n")

    # def _get_wires_list_from_port(self, port):
    #     wires = list()
    #     none_exist = True
    #     for p in port.pins:
    #         if p.wire is not None:
    #             none_exist = False
    #         wires.append(p.wire)
    #     if none_exist:
    #         return list()
    #     return wires

    # def _get_cable_list_from_port(self, port):
    #     cables = set()
    #     for p in port.pins:
    #         if p.wire != None:
    #             cables.add(p.wire.cable)
    #     return cables

    # def _write_port_list(self, definition):
    #     first = "\n"
    #     for p in definition.ports:
    #         cables = self._get_cable_list_from_port(p)
    #         for c in cables:
    #             self.file.write(first)
    #             self.file.write(self.direction_string_map[p.direction])
    #             self.file.write(" ")
    #             if len(c.wires) > 1 or c.lower_index != 0:
    #                 left = c.lower_index + len(c.wires) -1
    #                 right = c.lower_index
    #                 if not c.is_downto:
    #                     temp = left
    #                     left = right
    #                     right = temp
    #                 self.file.write("[" + str(left) + ":" + str(right) + "]")
    #             self._write_escapable_name(c.name)
    #             self.file.write(";")
    #     self.file.write("\n\n")

    # def _write_cable(self, cable):
    #     self.file.write("wire ")
    #     if cable.lower_index != 0 or not cable.is_scalar:
    #         if cable.is_downto:
    #             left = cable.lower_index + len(cable.wires) - 1
    #             right = cable.lower_index
    #         else:
    #             left = cable.lower_index
    #             right = cable.lower_index + len(cable.wires) - 1
    #         self.file.write("["+str(left)+":"+str(right)+"]")
    #     #self.file.write(cable.name)
    #     self._write_escapable_name(cable.name)
    #     self.file.write(";\n")

    # def _write_instanciation(self, instance):
    #     parameters = dict()
    #     for k, v in instance.data.items():
    #         if "VERILOG.star." == k[:13]:
    #             if v is not None:
    #                 self.file.write("(* " + k[13:] + " = " + v + " *)\n")
    #             else:
    #                 self.file.write("(* " + k[13:] + " *)\n")

    #         if "VERILOG.parameters." == k[:19]:
    #             parameters[k[19:]] = v
    #     #self.file.write(instance.reference.name)
    #     self._write_escapable_name(instance.reference.name)

    #     if len(parameters.items()) != 0:
    #         self.file.write(vt.OCTOTHORP)
    #         self.file.write(vt.OPEN_PARENTHESIS)
    #         self.file.write(vt.NEW_LINE)
    #         first = True
    #         for k,v in parameters.items():
    #             if first:
    #                 first = False
    #             else:
    #                 self.file.write(",\n")
    #             self.file.write("." + k + "(" + v + ")")
    #         self.file.write(")\n")
    #     self.file.write(" ")
    #     #self.file.write(instance.name)
    #     self._write_escapable_name(instance.name)
    #     self.file.write("\n(\n")
    #     first = True
    #     port_pin_dict = dict()
    #     for port in instance.reference.ports:
    #         port_pin_dict[port] = []
    #     for pin in instance.pins:
    #         port_pin_dict[pin.inner_pin.port].append(pin)
    #     for p in instance.reference.ports:
    #         cable_name = self._write_port_wires(port_pin_dict[p])
    #         if cable_name is not None:
    #             if first:
    #                 first = False
    #             #TODO: self.file.write(cableconnected to port name)
    #             else:
    #                 self.file.write(",\n")
    #             self.file.write("    .")
    #             self._write_escapable_name(p.name)
    #             self.file.write("(")
    #             #self._write_port_wires(port_pin_dict[p])
    #             #self.file.write(cable_name)
    #             self._write_escapable_name(cable_name)
    #             self.file.write(")")
    #     self.file.write("\n);\n")

    # def _write_port_wires(self, pins):
    #     '''takes a set of pins and returns a string that represents the given bus
    #     this bus can be a single cable all in order or a set of cables and indices'''
    #     string_to_write = ""
    #     previous_cable = None
    #     counting_down = None
    #     single_slice = True
    #     low_index = None
    #     high_index = None
    #     last_wire = False
    #     wire_exists = False

    #     #function here to help with code reuse. this function is really not needed elsewhere.
    #     def terminate_slice():
    #         nonlocal string_to_write
    #         nonlocal single_slice
    #         nonlocal low_index
    #         nonlocal high_index
    #         nonlocal counting_down
    #         if string_to_write == "" or string_to_write[0] != "{":
    #             string_to_write = "{ " + string_to_write
    #         if not single_slice:
    #             string_to_write += ", "
    #         string_to_write += self._get_indexed_name_from_cable(previous_cable, low_index, high_index, counting_down)
    #         single_slice = False
    #         low_index = None
    #         high_index = None
    #         counting_down = None

    #     for pin in pins:
    #         if pin.wire == None:
    #             last_wire = True
    #         else:
    #             wire_exists = True
    #             assert last_wire == False, "there is a gap in the port's pins to be wired up " + pin.inner_pin.port.name
    #             index = self._get_wire_index(pin.wire.cable, pin.wire)
    #             cable = pin.wire.cable

    #             if previous_cable != None and cable != previous_cable:

    #                 terminate_slice()

    #             elif previous_cable != None and cable == previous_cable:
    #                 if counting_down is None:
    #                     assert low_index == high_index, "counting_down should always be set if more than one wire has been used"
    #                     assert low_index != None, "at least one wire should have been seen by now..."
    #                     if abs(low_index - index) != 1:
    #                         terminate_slice()
    #                     else:
    #                         counting_down = index < low_index
    #                 elif counting_down and index == low_index - 1:
    #                     pass #we are still part of the same slice
    #                 elif not counting_down and index == high_index + 1:
    #                     pass #we are part of the same slice
    #                 else:
    #                     terminate_slice()

    #             if low_index is None or index < low_index:
    #                 low_index = index
    #             if high_index is None or index > high_index:
    #                 high_index = index
    #             previous_cable = cable

    #     if not wire_exists:
    #         return None
    #     if single_slice:
    #         assert string_to_write == "", "the string to write should be empty"
    #         string_to_write = self._get_indexed_name_from_cable(cable, low_index, high_index, counting_down)
    #     else:
    #         string_to_write +=", " + self._get_indexed_name_from_cable(cable, low_index, high_index, counting_down)
    #         string_to_write += " }"

    #     return string_to_write

    # def _get_wire_index(self, cable, wire):
    #     i = 0
    #     val = None
    #     for w in cable.wires:
    #         if wire == w:
    #             val = i
    #             break
    #         i += 1
    #     return val + cable.lower_index

    # def _get_indexed_name_from_cable(self, cable, low_index, high_index, downto):
    #     if cable.is_downto == downto:
    #         if low_index == cable.lower_index:
    #             if high_index == cable.lower_index + len(cable.wires) - 1:
    #                 return cable.name
    #     if high_index == low_index:
    #         return cable.name + " [" + str(high_index) + "] "
    #     if downto:
    #         return cable.name + " [" + str(high_index) + ":" + str(low_index) + "] "
    #     else:
    #         return cable.name + " [" + str(low_index) + ":" + str(high_index) + "] "

    ###########################################################################
    # Write verilog constructs
    ###########################################################################

    def _write_preprocessor_directives(self, module):
        '''write out the backtick preprocessor directives.
        this will likely just be `timescale 1 ps / 1 ps

        UPDATE: I'm just going to skip this for now.
        It can be added if simulation support is needed later'''
        pass  # not currently implemented, just pass

    def _write_star_constraints(self, object):
        if "VERILOG.InlineConstraints" in object and len(object["VERILOG.InlineConstraints"]) != 0:
            dictionary = object["VERILOG.InlineConstraints"]
            self.file.write(vt.OPEN_PARENTHESIS)
            self.file.write(vt.STAR)
            self.file.write(vt.SPACE)
            first = ""
            for k, v in dictionary.items():
                if v is not None:
                    self.file.write(first + k + vt.SPACE +
                                    vt.EQUAL + vt.SPACE + v)
                else:
                    self.file.write(first + k)
                first = vt.COMMA + vt.SPACE
            self.file.write(vt.SPACE)
            self.file.write(vt.STAR)
            self.file.write(vt.CLOSE_PARENTHESIS)
            self.file.write(vt.NEW_LINE)

    def _write_bundle_with_indicies(self, bundle, low, high):
        '''write out a bundle name and indicies. in name indicies order.
        useful for cable and port instances'''
        self._write_name(bundle)
        self._write_brackets(bundle, low, high)

    def _write_module(self, definition):
        '''write the constraints then the module header then the module body'''
        if definition.library.name == "SDN_VERILOG_ASSIGNMENT":
            return  # don't write assignment definitions
        if definition.library.name == "SDN.verilog_primitives":
            self.file.write(vt.CELL_DEFINE)
            self.file.write(vt.NEW_LINE)
        self._write_star_constraints(definition)
        self._write_module_header(definition)
        self._write_module_body(definition)
        self.file.write(vt.END_MODULE)
        if definition.library.name == "SDN.verilog_primitives":
            self.file.write(vt.NEW_LINE)
            self.file.write(vt.END_CELL_DEFINE)

        self.file.write(2 * vt.NEW_LINE)

    def _write_module_header(self, definition):
        '''write out the module header with the following style:
        module module_name (port_name, port_name);
        start with module and end with semi colon
        '''
        self.file.write(vt.MODULE)
        self.file.write(vt.SPACE)
        self.file.write(definition.name)
        self.file.write(vt.NEW_LINE)
        if "VERILOG.Parameters" in definition:
            self._write_module_parameters(definition)
        self._write_module_header_ports(definition)
        self.file.write(vt.NEW_LINE)

    def _write_module_body(self, definition):
        '''write out the module body start with ports, then do assignments then instances'''
        self._write_module_body_ports(definition)
        if definition.library.name != "SDN.verilog_primitives":
            self._write_module_body_cables(definition)
            self._write_assignments(definition)
            self._write_module_body_instances(definition)

    def _write_module_body_instances(self, definition):
        for c in definition.children:
            self._write_module_body_instance(c)

    def _write_module_body_instance(self, instance):
        if instance.reference.library.name == "SDN_VERILOG_ASSIGNMENT":
            return  # do not write the assignment instance
        self._write_star_constraints(instance)
        self.file.write(self.indent_count * vt.SPACE)
        self.file.write(instance.reference.name)
        self.file.write(vt.SPACE)
        if "VERILOG.Parameters" in instance:
            self._write_instance_parameters(instance)
            self.file.write(self.indent_count * vt.SPACE)
        self.file.write(instance.name)
        self.file.write(vt.NEW_LINE)
        self._write_instance_ports(instance)
        self.file.write(vt.NEW_LINE)

    def _write_module_body_ports(self, definition):
        for p in definition.ports:
            self._write_module_body_port(p)
        self.file.write(vt.NEW_LINE)

    def _write_module_body_port(self, port):
        _, cables = self._all_wires_and_cables_from_pinset(port.pins)
        for c in cables:
            self._write_star_constraints(port)
            self.file.write(self.indent_count * vt.SPACE)
            self.file.write(self.direction_string_map[port.direction])
            self.file.write(vt.SPACE)
            self._write_brackets_defining(c)
            self.file.write(c.name)
            self.file.write(vt.SEMI_COLON)
            self.file.write(vt.NEW_LINE)

    def _write_module_body_cables(self, definition):
        for c in definition.cables:
            self._write_module_body_cable(c)
        self.file.write(vt.NEW_LINE)

    def _write_module_body_cable(self, cable):
        self._write_star_constraints(cable)
        self.file.write(self.indent_count * vt.SPACE)
        self.file.write(vt.WIRE)
        self.file.write(vt.SPACE)
        self._write_brackets_defining(cable)
        self.file.write(cable.name)
        self.file.write(vt.SEMI_COLON)
        self.file.write(vt.NEW_LINE)

    def _write_concatenation(self, wires):
        '''write out the concatenation statement
        {wire_1, wire_2}'''
        self.file.write(vt.OPEN_BRACE)
        first = True
        for w in wires:
            if w is not None:
                if not first:
                    self.file.write(vt.COMMA)
                    self.file.write(vt.SPACE)
                index = self._index_of_wire_in_cable(w)
                self._write_bundle_with_indicies(w.cable, index, None)
            else:
                break

            first = False
        self.file.write(vt.CLOSE_BRACE)

    def _write_module_header_ports(self, definition):
        self.file.write(vt.OPEN_PARENTHESIS)
        self.file.write(vt.NEW_LINE)
        first = True
        for p in definition.ports:
            if not first:
                self.file.write(vt.COMMA)
            self._write_module_header_port(p)
            first = False
        self.file.write(vt.CLOSE_PARENTHESIS)
        self.file.write(vt.SEMI_COLON)
        self.file.write(vt.NEW_LINE)

    def _write_module_header_port(self, port):
        '''does not write the input output or width, 
        check for concatenation port as well'''
        self.file.write(vt.NEW_LINE + (self.indent_count * vt.SPACE))
        aliased = self._is_pinset_concatenated(port.pins, port.name)
        if aliased:
            wires = []
            for p in port.pins:
                wires.append(p.wire)
            self.file.write(vt.DOT)
            self.file.write(port.name)
            self.file.write(vt.OPEN_PARENTHESIS)
            self._write_concatenation(wires)
            self.file.write(vt.CLOSE_PARENTHESIS)
        else:
            self.file.write(port.name)

    def _write_assignments(self, definition):
        for c in definition.children:
            if c.reference.library.name == "SDN_VERILOG_ASSIGNMENT":
                self._write_assignment(c)

    def _write_assignment(self, instance):
        '''take an assignment instance and write an assignment out
        assign cable_out = cable_in;'''
        in_port = None
        out_port = None
        for p in instance.reference.ports:
            if p.name == "o":
                out_port = p
            if p.name == "i":
                in_port = p
        assert in_port is not None, self._error_string(
            "instance does not appear to be an assignment with a port named i and o", instance)
        assert out_port is not None, self._error_string(
            "instance does not appear to be an assignment with a port named i and o", instance)
        left_wires = []
        right_wires = []
        in_pins = []
        out_pins = []
        for p in in_port.pins:
            in_pins.append(instance.pins[p])
        for p in out_port.pins:
            out_pins.append(instance.pins[p])
        in_wires, in_cables = self._all_wires_and_cables_from_pinset(in_pins)
        out_wires, out_cables = self._all_wires_and_cables_from_pinset(
            out_pins)
        assert not self._is_pinset_concatenated(in_pins, in_wires[0].cable.name), self._error_string(
            "multiple cables appear to be connected to a single assignment input", instance)
        assert not self._is_pinset_concatenated(out_pins, out_wires[0].cable.name), self._error_string(
            "multiple cables appear to be connected to a single assignment output", instance)
        self.file.write(vt.ASSIGN)
        self.file.write(vt.SPACE)
        hi = self._index_of_wire_in_cable(out_wires[-1])
        li = self._index_of_wire_in_cable(out_wires[0])
        self._write_bundle_with_indicies(out_cables.pop(), li, hi)
        self.file.write(vt.SPACE)
        self.file.write(vt.EQUAL)
        self.file.write(vt.SPACE)
        hi = self._index_of_wire_in_cable(in_wires[-1])
        li = self._index_of_wire_in_cable(in_wires[0])
        self._write_bundle_with_indicies(in_cables.pop(), li, hi)
        self.file.write(vt.SEMI_COLON)
        self.file.write(vt.NEW_LINE)

    def _write_module_parameters(self, definition):
        '''write out the parameters in the module header'''
        self.file.write(vt.OCTOTHORP)
        self.file.write(vt.OPEN_PARENTHESIS)
        indentation = "\n    "
        first = True
        for k, v in definition["VERILOG.Parameters"].items():
            if not first:
                self.file.write(vt.COMMA)
            self.file.write(indentation)
            self.file.write(vt.PARAMETER)
            self.file.write(vt.SPACE)
            self.file.write(k)
            if v is not None:
                self.file.write(" " + vt.EQUAL + " ")
                self.file.write(v)
            first = False
        self.file.write(vt.NEW_LINE)
        self.file.write(vt.CLOSE_PARENTHESIS)

    def _write_instance_parameters(self, instance):
        '''write out the parameters in the instance
        #(
        .key(value),
        ...
        )'''
        self.file.write(vt.OCTOTHORP)
        self.file.write(vt.OPEN_PARENTHESIS)
        self.file.write(vt.NEW_LINE)
        first = True
        for k, v in instance["VERILOG.Parameters"].items():
            if not first:
                self.file.write(vt.COMMA)
                self.file.write(vt.NEW_LINE)
            self._write_instance_parameter(k, v)
            first = False
        self.file.write(vt.NEW_LINE)
        self.file.write(self.indent_count * vt.SPACE)
        self.file.write(vt.CLOSE_PARENTHESIS)
        self.file.write(vt.NEW_LINE)

    def _write_instance_parameter(self, key, value):
        self.file.write(2*self.indent_count * vt.SPACE)
        self.file.write(vt.DOT)
        self.file.write(key)
        self.file.write(vt.OPEN_PARENTHESIS)
        self.file.write(value)
        self.file.write(vt.CLOSE_PARENTHESIS)

    def _write_instance_ports(self, instance):
        '''write out the port mapping on an instance.'''
        self.file.write(self.indent_count * vt.SPACE)
        self.file.write(vt.OPEN_PARENTHESIS)
        self.file.write(vt.NEW_LINE)
        first = True
        for p in instance.reference.ports:
            if not first:
                self.file.write(vt.COMMA)
                self.file.write(vt.NEW_LINE)
            self._write_instance_port(instance, p)
            first = False
        self.file.write(vt.NEW_LINE)
        self.file.write(self.indent_count * vt.SPACE)
        self.file.write(vt.CLOSE_PARENTHESIS)
        self.file.write(vt.SEMI_COLON)

    def _write_instance_port(self, instance, port):
        self.file.write(2*self.indent_count * vt.SPACE)
        self.file.write(vt.DOT)
        self.file.write(port.name)
        self.file.write(vt.OPEN_PARENTHESIS)
        pins = []
        for p in port.pins:
            pins.append(instance.pins[p])
        if pins[0].wire is not None:
            name = pins[0].wire.cable.name
        else:
            name = None
        concatenated = self._is_pinset_concatenated(pins, name)
        wires = []
        for p in pins:
            wires.append(p.wire)
        if concatenated:
            self._write_concatenation(wires)
        else:
            if pins[0].wire is not None:
                # if name is not None:
                #     self.file.write(name)
                last = -1
                wl = wires[last]
                wr = wires[0]
                while wl is None:  # get the last named non none wire.
                    last = last - 1
                    wl = wires[last]
                il = self._index_of_wire_in_cable(wl)
                ir = self._index_of_wire_in_cable(wr)
                self._write_bundle_with_indicies(wl.cable, ir, il)

        self.file.write(vt.CLOSE_PARENTHESIS)

    def _write_name(self, object):
        '''write the name of an object. this is split out to give an error message if the name is not set
        In the future this could be changed to add a name to objects that do not have a name set'''
        assert object.name is not None, self._error_string(
            "name of object is not set", object)
        if object.name[0] == '\\':
            assert object.name[-1] == ' ', self._error_string(
                "the object name starts with escape and does not end with a space.", object)
        self.file.write(object.name)
        self.file.write(" ")

    def _write_brackets_defining(self, bundle):
        '''write the brackets for port or cable definitions'''
        if isinstance(bundle, Cable):
            array = bundle.wires
        elif isinstance(bundle, Port):
            array = bundle.pins
        width = len(array)

        assert width != 0, self._error_string(
            "bundle has 0 width, this will not write correctly please add a pin to the port or wire to the cable.", bundle)

        if width == 1 and bundle.lower_index == 0:
            return  # no need to write because this is assumed

        self.file.write(vt.OPEN_BRACKET)
        self.file.write(str(bundle.lower_index + width - 1))
        self.file.write(vt.COLON)
        self.file.write(str(bundle.lower_index))
        self.file.write(vt.CLOSE_BRACKET)

    def _write_brackets(self, bundle, low_index, high_index):
        '''write a bundle's brackets based on the low and high indicies given
        does not write out the name, works on both cables and ports'''
        if low_index == None and high_index == None:
            return  # nothing to write.

        if isinstance(bundle, Cable):
            array = bundle.wires
        elif isinstance(bundle, Port):
            array = bundle.pins
        width = len(array)
        assert width != 0, self._error_string(
            "cannot index into 0 width cable")
        lower_bundle = bundle.lower_index
        upper_bundle = lower_bundle + width - 1

        if low_index == lower_bundle and high_index == upper_bundle:
            # no need to write if the upper and lower indicies cover the whole bundle.
            return
        elif low_index == high_index:
            self.file.write("[" + str(low_index) + "]")
        elif low_index is not None and high_index is None:
            self.file.write("[" + str(low_index) + "]")
        elif high_index is not None and low_index is None:
            self.file.write("[" + str(high_index) + "]")
        else:
            assert low_index is not None and high_index is not None,\
                self._error_string(
                    "low_index and high_index should both not be None at this point in the function")
            self.file.write(
                "[" + str(high_index) + ":" + str(low_index) + "] ")

    ###############################################################################
    # helper functions for composing
    ###############################################################################

    def _index_of_wire_in_cable(self, wire):
        index = 0
        for w in wire.cable.wires:
            if w == wire:
                return index + wire.cable.lower_index
            index += 1
        return None

    def _is_pinset_concatenated(self, pins, name):
        aliased = False
        now_none = False
        last_index = None
        for p in pins:
            if p.wire is None:
                next_name = None
                now_none = True
            else:
                next_name = p.wire.cable.name
                if now_none == True:
                    aliased = True
                index = self._index_of_wire_in_cable(p.wire)
                if last_index == None:
                    last_index = index
                else:
                    if index != last_index + 1:
                        aliased = True
                        break
            if next_name != name and not now_none:
                aliased = True
                break
        return aliased

    def _all_wires_and_cables_from_pinset(self, pins):
        wires = []
        cables = set()
        for p in pins:
            wires.append(p.wire)
            cables.add(p.wire.cable)
        return wires, cables

    def _error_string(self, message, object):
        return "compose error: " + message + str(object)

    def _write_escapable_name(self, str_in):
        if str_in[0] == "\\":
            self.file.write(str_in + " ")
        else:
            self.file.write(str_in)
